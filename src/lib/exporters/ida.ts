/**
 * IDA Pro Python script exporter
 * Generates Python scripts that create structs/enums in IDA
 */

import type { YamlStruct, YamlField, YamlEnum } from '../types.js';
import { parseOffset, toHex } from '../types.js';
import {
  type Exporter,
  type ExportOptions,
  type ExportResult,
  mapToIdaType,
  getTypeSize,
  sanitizeIdentifier,
  parseArrayType,
} from './base.js';

export const idaExporter: Exporter = {
  format: 'ida',
  extension: '.py',
  export: exportToIda,
};

function exportToIda(
  structs: YamlStruct[],
  enums: YamlEnum[],
  options: ExportOptions = {}
): ExportResult {
  const warnings: string[] = [];
  const lines: string[] = [];

  // Header
  lines.push('"""');
  lines.push('FFXIVClientStructs - IDA Type Import Script');
  lines.push('Generated by ffxiv-struct-tools');
  lines.push('');
  lines.push('Usage: In IDA, go to File > Script file... and select this script');
  lines.push('"""');
  lines.push('');
  lines.push('import idc');
  lines.push('import ida_struct');
  lines.push('import ida_bytes');
  lines.push('import ida_typeinf');
  lines.push('import ida_nalt');
  lines.push('');

  // Helper functions
  lines.push('# Helper functions');
  lines.push('def get_or_create_struct(name, size=0):');
  lines.push('    """Get existing struct or create new one"""');
  lines.push('    sid = ida_struct.get_struc_id(name)');
  lines.push('    if sid == idc.BADADDR:');
  lines.push('        sid = ida_struct.add_struc(-1, name, False)');
  lines.push('    return sid');
  lines.push('');
  lines.push('def add_struct_member(sid, name, offset, type_str, size, is_array=False, array_count=1):');
  lines.push('    """Add or update a struct member"""');
  lines.push('    sptr = ida_struct.get_struc(sid)');
  lines.push('    if sptr is None:');
  lines.push('        return False');
  lines.push('    ');
  lines.push('    # Remove existing member at offset if any');
  lines.push('    member = ida_struct.get_member(sptr, offset)');
  lines.push('    if member:');
  lines.push('        ida_struct.del_struc_member(sptr, offset)');
  lines.push('    ');
  lines.push('    # Determine flags based on size');
  lines.push('    if size == 1:');
  lines.push('        flag = ida_bytes.FF_BYTE');
  lines.push('    elif size == 2:');
  lines.push('        flag = ida_bytes.FF_WORD');
  lines.push('    elif size == 4:');
  lines.push('        flag = ida_bytes.FF_DWORD');
  lines.push('    elif size == 8:');
  lines.push('        flag = ida_bytes.FF_QWORD');
  lines.push('    else:');
  lines.push('        flag = ida_bytes.FF_BYTE');
  lines.push('    ');
  lines.push('    total_size = size * array_count if is_array else size');
  lines.push('    ida_struct.add_struc_member(sptr, name, offset, flag, None, total_size)');
  lines.push('    return True');
  lines.push('');
  lines.push('def create_enum(name, values, underlying_size=4):');
  lines.push('    """Create an enum type"""');
  lines.push('    eid = idc.get_enum(name)');
  lines.push('    if eid == idc.BADADDR:');
  lines.push('        if underlying_size == 1:');
  lines.push('            eid = idc.add_enum(-1, name, ida_bytes.FF_BYTE)');
  lines.push('        elif underlying_size == 2:');
  lines.push('            eid = idc.add_enum(-1, name, ida_bytes.FF_WORD)');
  lines.push('        else:');
  lines.push('            eid = idc.add_enum(-1, name, ida_bytes.FF_DWORD)');
  lines.push('    ');
  lines.push('    for val_name, val in values.items():');
  lines.push('        idc.add_enum_member(eid, val_name, val, -1)');
  lines.push('    ');
  lines.push('    return eid');
  lines.push('');
  lines.push('');

  // Export enums first (structs may reference them)
  lines.push('# ============================================================');
  lines.push('# Enums');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def create_enums():');
  lines.push('    """Create all enum types"""');

  if (enums.length === 0) {
    lines.push('    pass  # No enums to create');
  } else {
    for (const enumDef of enums) {
      const enumName = sanitizeIdentifier(enumDef.type);
      const underlyingSize = getEnumUnderlyingSize(enumDef.underlying);

      lines.push(`    # ${enumDef.type}`);
      lines.push(`    create_enum("${enumName}", {`);

      if (enumDef.values) {
        for (const [name, value] of Object.entries(enumDef.values)) {
          const safeValue = typeof value === 'string' ? parseInt(value, 10) : value;
          lines.push(`        "${sanitizeIdentifier(name)}": ${safeValue},`);
        }
      }

      lines.push(`    }, ${underlyingSize})`);
      lines.push('');
    }
  }

  lines.push('');

  // Export structs
  lines.push('# ============================================================');
  lines.push('# Structs');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def create_structs():');
  lines.push('    """Create all struct types"""');

  if (structs.length === 0) {
    lines.push('    pass  # No structs to create');
  } else {
    for (const struct of structs) {
      const structName = sanitizeIdentifier(struct.type);
      const size = struct.size || 0;

      lines.push(`    # ${struct.type} (size: ${toHex(size)})`);
      if (options.includeComments && struct.notes) {
        for (const noteLine of struct.notes.split('\n')) {
          lines.push(`    # ${noteLine}`);
        }
      }
      lines.push(`    sid = get_or_create_struct("${structName}", ${size})`);

      if (struct.fields && struct.fields.length > 0) {
        for (const field of struct.fields) {
          // Add field note as comment if enabled
          if (options.includeComments && field.notes) {
            lines.push(`    # ${field.name || 'field'}: ${field.notes}`);
          }
          const fieldLine = generateFieldLine(field, struct.type, warnings);
          if (fieldLine) {
            lines.push(`    ${fieldLine}`);
          }
        }
      }

      lines.push('');
    }
  }

  lines.push('');

  // Main execution
  lines.push('# ============================================================');
  lines.push('# Main');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def main():');
  lines.push('    print("[FFXIVClientStructs] Starting type import...")');
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating enums...")');
  lines.push('    create_enums()');
  lines.push(`    print("[FFXIVClientStructs] Created ${enums.length} enums")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating structs...")');
  lines.push('    create_structs()');
  lines.push(`    print("[FFXIVClientStructs] Created ${structs.length} structs")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Import complete!")');
  lines.push('');
  lines.push('if __name__ == "__main__":');
  lines.push('    main()');
  lines.push('');

  return {
    content: lines.join('\n'),
    filename: options.output || 'ffxiv_structs_ida.py',
    structCount: structs.length,
    enumCount: enums.length,
    warnings,
  };
}

function generateFieldLine(
  field: YamlField,
  structName: string,
  warnings: string[]
): string | null {
  const offset = parseOffset(field.offset);
  const fieldName = sanitizeIdentifier(field.name || `field_${toHex(offset)}`);

  // Check for array types
  const arrayInfo = parseArrayType(field.type);
  if (arrayInfo) {
    const baseSize = getTypeSize(arrayInfo.baseType);
    return `add_struct_member(sid, "${fieldName}", ${toHex(offset)}, "${mapToIdaType(arrayInfo.baseType)}", ${baseSize}, True, ${arrayInfo.count})`;
  }

  // Regular type
  const idaType = mapToIdaType(field.type);
  const size = field.size || getTypeSize(field.type);

  return `add_struct_member(sid, "${fieldName}", ${toHex(offset)}, "${idaType}", ${size})`;
}

function getEnumUnderlyingSize(underlying?: string): number {
  if (!underlying) return 4;

  const sizeMap: Record<string, number> = {
    'byte': 1,
    'sbyte': 1,
    'short': 2,
    'ushort': 2,
    'int': 4,
    'uint': 4,
    'long': 8,
    'ulong': 8,
  };

  return sizeMap[underlying.toLowerCase()] || 4;
}

export default idaExporter;
