/**
 * IDA Pro Python script exporter
 * Generates Python scripts that create structs/enums in IDA
 * Supports both IDA 8.x (ida_struct/idc) and IDA 9.0+ (ida_typeinf)
 */

import type { YamlStruct, YamlField, YamlEnum } from '../types.js';
import { parseOffset, toHex } from '../types.js';
import {
  type Exporter,
  type ExportOptions,
  type ExportResult,
  mapToIdaType,
  getTypeSize,
  sanitizeIdentifier,
  parseArrayType,
} from './base.js';

export const idaExporter: Exporter = {
  format: 'ida',
  extension: '.py',
  export: exportToIda,
};

function exportToIda(
  structs: YamlStruct[],
  enums: YamlEnum[],
  options: ExportOptions = {}
): ExportResult {
  const warnings: string[] = [];
  const lines: string[] = [];

  // Header
  lines.push('"""');
  lines.push('FFXIVClientStructs - IDA Type Import Script');
  lines.push('Generated by ffxiv-struct-tools');
  lines.push('');
  lines.push('Supports IDA 8.x and IDA 9.0+');
  lines.push('');
  lines.push('Usage: In IDA, go to File > Script file... and select this script');
  lines.push('"""');
  lines.push('');

  // Version-aware imports
  lines.push('import idaapi');
  lines.push('import ida_bytes');
  lines.push('');
  lines.push('# Detect IDA version for API compatibility');
  lines.push('IDA9 = idaapi.IDA_SDK_VERSION >= 900');
  lines.push('');
  lines.push('if IDA9:');
  lines.push('    import ida_typeinf');
  lines.push('else:');
  lines.push('    import idc');
  lines.push('    import ida_struct');
  lines.push('    import ida_nalt');
  lines.push('');

  // Helper functions with dual-version support
  generateHelperFunctions(lines);

  // Export enums first (structs may reference them)
  lines.push('# ============================================================');
  lines.push('# Enums');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def create_enums():');
  lines.push('    """Create all enum types"""');

  if (enums.length === 0) {
    lines.push('    pass  # No enums to create');
  } else {
    for (const enumDef of enums) {
      const enumName = sanitizeIdentifier(enumDef.type);
      const underlyingSize = getEnumUnderlyingSize(enumDef.underlying);

      lines.push(`    # ${enumDef.type}`);
      lines.push(`    create_enum("${enumName}", {`);

      if (enumDef.values) {
        for (const [name, value] of Object.entries(enumDef.values)) {
          const safeValue = typeof value === 'string' ? parseInt(value, 10) : value;
          lines.push(`        "${sanitizeIdentifier(name)}": ${safeValue},`);
        }
      }

      lines.push(`    }, ${underlyingSize})`);
      lines.push('');
    }
  }

  lines.push('');

  // Export structs
  lines.push('# ============================================================');
  lines.push('# Structs');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def create_structs():');
  lines.push('    """Create all struct types"""');

  if (structs.length === 0) {
    lines.push('    pass  # No structs to create');
  } else {
    for (const struct of structs) {
      const structName = sanitizeIdentifier(struct.type);
      const size = struct.size || 0;

      lines.push(`    # ${struct.type} (size: ${toHex(size)})`);
      if (options.includeComments && struct.notes) {
        for (const noteLine of struct.notes.split('\n')) {
          lines.push(`    # ${noteLine}`);
        }
      }
      lines.push(`    struct_handle = get_or_create_struct("${structName}", ${size})`);

      if (struct.fields && struct.fields.length > 0) {
        for (const field of struct.fields) {
          // Add field note as comment if enabled
          if (options.includeComments && field.notes) {
            lines.push(`    # ${field.name || 'field'}: ${field.notes}`);
          }
          const fieldLine = generateFieldLine(field, struct.type, warnings);
          if (fieldLine) {
            lines.push(`    ${fieldLine}`);
          }
        }
      }

      // Handle vtable if struct has virtual functions
      if (struct.vfuncs && struct.vfuncs.length > 0) {
        const vtableName = `${structName}_VTable`;
        lines.push(`    # Create vtable for ${structName}`);
        lines.push(`    vtable_handle = create_vtable("${vtableName}", [`);

        // Sort vfuncs by id for proper slot ordering
        const sortedVfuncs = [...struct.vfuncs]
          .filter(vf => vf.id !== undefined)
          .sort((a, b) => (a.id ?? 0) - (b.id ?? 0));

        for (const vfunc of sortedVfuncs) {
          const vfuncName = sanitizeIdentifier(vfunc.name || `vfunc_${vfunc.id}`);
          lines.push(`        (${vfunc.id}, "${vfuncName}"),`);
        }

        lines.push(`    ])`);
        lines.push(`    apply_vtable_to_struct("${structName}", struct_handle, "${vtableName}", vtable_handle)`);
      }

      // Finalize struct in IDA 9
      lines.push(`    finalize_struct("${structName}", struct_handle, ${size})`);
      lines.push('');
    }
  }

  lines.push('');

  // Main execution
  lines.push('# ============================================================');
  lines.push('# Main');
  lines.push('# ============================================================');
  lines.push('');
  lines.push('def main():');
  lines.push('    version_str = "IDA 9+" if IDA9 else "IDA 8.x"');
  lines.push('    print(f"[FFXIVClientStructs] Starting type import (detected {version_str})...")');
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating enums...")');
  lines.push('    create_enums()');
  lines.push(`    print("[FFXIVClientStructs] Created ${enums.length} enums")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating structs...")');
  lines.push('    create_structs()');
  lines.push(`    print("[FFXIVClientStructs] Created ${structs.length} structs")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Import complete!")');
  lines.push('');
  lines.push('if __name__ == "__main__":');
  lines.push('    main()');
  lines.push('');

  return {
    content: lines.join('\n'),
    filename: options.output || 'ffxiv_structs_ida.py',
    structCount: structs.length,
    enumCount: enums.length,
    warnings,
  };
}

/**
 * Generate the dual-version helper functions
 */
function generateHelperFunctions(lines: string[]): void {
  lines.push('# ============================================================');
  lines.push('# Helper functions (dual IDA 8/9 support)');
  lines.push('# ============================================================');
  lines.push('');

  // Type size to flag mapping
  lines.push('def get_type_flag(size):');
  lines.push('    """Map byte size to IDA type flag"""');
  lines.push('    return {');
  lines.push('        1: ida_bytes.FF_BYTE,');
  lines.push('        2: ida_bytes.FF_WORD,');
  lines.push('        4: ida_bytes.FF_DWORD,');
  lines.push('        8: ida_bytes.FF_QWORD,');
  lines.push('    }.get(size, ida_bytes.FF_BYTE)');
  lines.push('');

  // IDA 9 type mapping
  lines.push('def get_ida9_base_type(size):');
  lines.push('    """Map byte size to IDA 9 BT_* type constant"""');
  lines.push('    if not IDA9:');
  lines.push('        return None');
  lines.push('    return {');
  lines.push('        1: ida_typeinf.BT_INT8,');
  lines.push('        2: ida_typeinf.BT_INT16,');
  lines.push('        4: ida_typeinf.BT_INT32,');
  lines.push('        8: ida_typeinf.BT_INT64,');
  lines.push('    }.get(size, ida_typeinf.BT_INT8)');
  lines.push('');

  // get_or_create_struct - dual version
  lines.push('def get_or_create_struct(name, size=0):');
  lines.push('    """Get existing struct or create new one (IDA 8/9 compatible)"""');
  lines.push('    if IDA9:');
  lines.push('        return get_or_create_struct_ida9(name, size)');
  lines.push('    else:');
  lines.push('        return get_or_create_struct_ida8(name, size)');
  lines.push('');

  // IDA 8 version
  lines.push('def get_or_create_struct_ida8(name, size=0):');
  lines.push('    """IDA 8.x: Get or create struct using ida_struct"""');
  lines.push('    sid = ida_struct.get_struc_id(name)');
  lines.push('    if sid == idc.BADADDR:');
  lines.push('        sid = ida_struct.add_struc(-1, name, False)');
  lines.push('    return {"sid": sid, "members": []}');
  lines.push('');

  // IDA 9 version
  lines.push('def get_or_create_struct_ida9(name, size=0):');
  lines.push('    """IDA 9+: Get or create struct using ida_typeinf"""');
  lines.push('    tif = ida_typeinf.tinfo_t()');
  lines.push('    til = ida_typeinf.get_idati()');
  lines.push('    ');
  lines.push('    # Check if type already exists');
  lines.push('    if tif.get_named_type(til, name):');
  lines.push('        return {"tif": tif, "udt": ida_typeinf.udt_type_data_t(), "name": name, "members": []}');
  lines.push('    ');
  lines.push('    # Create new struct type');
  lines.push('    udt = ida_typeinf.udt_type_data_t()');
  lines.push('    return {"tif": tif, "udt": udt, "name": name, "members": []}');
  lines.push('');

  // add_struct_member - dual version
  lines.push('def add_struct_member(struct_handle, name, offset, type_str, size, is_array=False, array_count=1):');
  lines.push('    """Add or update a struct member (IDA 8/9 compatible)"""');
  lines.push('    if IDA9:');
  lines.push('        return add_struct_member_ida9(struct_handle, name, offset, type_str, size, is_array, array_count)');
  lines.push('    else:');
  lines.push('        return add_struct_member_ida8(struct_handle, name, offset, type_str, size, is_array, array_count)');
  lines.push('');

  // IDA 8 add member
  lines.push('def add_struct_member_ida8(struct_handle, name, offset, type_str, size, is_array=False, array_count=1):');
  lines.push('    """IDA 8.x: Add struct member using ida_struct"""');
  lines.push('    sid = struct_handle["sid"]');
  lines.push('    sptr = ida_struct.get_struc(sid)');
  lines.push('    if sptr is None:');
  lines.push('        return False');
  lines.push('    ');
  lines.push('    # Remove existing member at offset if any');
  lines.push('    member = ida_struct.get_member(sptr, offset)');
  lines.push('    if member:');
  lines.push('        ida_struct.del_struc_member(sptr, offset)');
  lines.push('    ');
  lines.push('    flag = get_type_flag(size)');
  lines.push('    total_size = size * array_count if is_array else size');
  lines.push('    ida_struct.add_struc_member(sptr, name, offset, flag, None, total_size)');
  lines.push('    return True');
  lines.push('');

  // IDA 9 add member
  lines.push('def add_struct_member_ida9(struct_handle, name, offset, type_str, size, is_array=False, array_count=1):');
  lines.push('    """IDA 9+: Add struct member to udt_type_data_t for later creation"""');
  lines.push('    total_size = size * array_count if is_array else size');
  lines.push('    struct_handle["members"].append({');
  lines.push('        "name": name,');
  lines.push('        "offset": offset,');
  lines.push('        "size": size,');
  lines.push('        "total_size": total_size,');
  lines.push('        "is_array": is_array,');
  lines.push('        "array_count": array_count,');
  lines.push('    })');
  lines.push('    return True');
  lines.push('');

  // finalize_struct - applies accumulated members in IDA 9
  lines.push('def finalize_struct(name, struct_handle, total_size):');
  lines.push('    """Finalize struct creation (IDA 9 commits the type, IDA 8 is no-op)"""');
  lines.push('    if not IDA9:');
  lines.push('        return True');
  lines.push('    ');
  lines.push('    tif = struct_handle["tif"]');
  lines.push('    udt = struct_handle["udt"]');
  lines.push('    members = struct_handle["members"]');
  lines.push('    ');
  lines.push('    # Sort members by offset to ensure correct ordering');
  lines.push('    members.sort(key=lambda m: m["offset"])');
  lines.push('    ');
  lines.push('    # Add all members to UDT');
  lines.push('    for m in members:');
  lines.push('        udm = ida_typeinf.udm_t()');
  lines.push('        udm.name = m["name"]');
  lines.push('        udm.offset = m["offset"] * 8  # Convert bytes to bits');
  lines.push('        ');
  lines.push('        # Create member type');
  lines.push('        member_type = ida_typeinf.tinfo_t()');
  lines.push('        bt = get_ida9_base_type(m["size"])');
  lines.push('        member_type.create_simple_type(bt)');
  lines.push('        ');
  lines.push('        # Handle array types');
  lines.push('        if m["is_array"]:');
  lines.push('            array_type = ida_typeinf.tinfo_t()');
  lines.push('            array_type.create_array(member_type, m["array_count"])');
  lines.push('            udm.type = array_type');
  lines.push('            udm.size = m["total_size"] * 8');
  lines.push('        else:');
  lines.push('            udm.type = member_type');
  lines.push('            udm.size = m["size"] * 8');
  lines.push('        ');
  lines.push('        udt.push_back(udm)');
  lines.push('    ');
  lines.push('    # Create and register the struct type');
  lines.push('    if tif.create_udt(udt, ida_typeinf.BTF_STRUCT):');
  lines.push('        tif.set_named_type(None, name)');
  lines.push('    return True');
  lines.push('');

  // create_enum - dual version
  lines.push('def create_enum(name, values, underlying_size=4):');
  lines.push('    """Create an enum type (IDA 8/9 compatible)"""');
  lines.push('    if IDA9:');
  lines.push('        return create_enum_ida9(name, values, underlying_size)');
  lines.push('    else:');
  lines.push('        return create_enum_ida8(name, values, underlying_size)');
  lines.push('');

  // IDA 8 enum creation
  lines.push('def create_enum_ida8(name, values, underlying_size=4):');
  lines.push('    """IDA 8.x: Create enum using idc"""');
  lines.push('    eid = idc.get_enum(name)');
  lines.push('    if eid == idc.BADADDR:');
  lines.push('        flag = get_type_flag(underlying_size)');
  lines.push('        eid = idc.add_enum(-1, name, flag)');
  lines.push('    ');
  lines.push('    for val_name, val in values.items():');
  lines.push('        idc.add_enum_member(eid, val_name, val, -1)');
  lines.push('    ');
  lines.push('    return eid');
  lines.push('');

  // IDA 9 enum creation
  lines.push('def create_enum_ida9(name, values, underlying_size=4):');
  lines.push('    """IDA 9+: Create enum using ida_typeinf"""');
  lines.push('    tif = ida_typeinf.tinfo_t()');
  lines.push('    til = ida_typeinf.get_idati()');
  lines.push('    ');
  lines.push('    # Check if enum already exists');
  lines.push('    if tif.get_named_type(til, name):');
  lines.push('        return tif');
  lines.push('    ');
  lines.push('    # Create enum type data');
  lines.push('    enum_data = ida_typeinf.enum_type_data_t()');
  lines.push('    ');
  lines.push('    # Add enum members');
  lines.push('    edm = ida_typeinf.edm_t()');
  lines.push('    for val_name, val in values.items():');
  lines.push('        edm.name = val_name');
  lines.push('        edm.value = val');
  lines.push('        enum_data.push_back(edm)');
  lines.push('    ');
  lines.push('    # Create and register the enum type');
  lines.push('    if tif.create_enum(enum_data):');
  lines.push('        tif.set_named_type(None, name)');
  lines.push('    return tif');
  lines.push('');

  // VTable creation helper - dual version
  lines.push('def create_vtable(name, vfuncs):');
  lines.push('    """Create a vtable struct with function pointers (IDA 8/9 compatible)');
  lines.push('    ');
  lines.push('    Args:');
  lines.push('        name: VTable struct name');
  lines.push('        vfuncs: List of (slot_id, func_name) tuples');
  lines.push('    """');
  lines.push('    if IDA9:');
  lines.push('        return create_vtable_ida9(name, vfuncs)');
  lines.push('    else:');
  lines.push('        return create_vtable_ida8(name, vfuncs)');
  lines.push('');

  // IDA 8 vtable creation
  lines.push('def create_vtable_ida8(name, vfuncs):');
  lines.push('    """IDA 8.x: Create vtable using ida_struct"""');
  lines.push('    sid = ida_struct.get_struc_id(name)');
  lines.push('    if sid == idc.BADADDR:');
  lines.push('        sid = ida_struct.add_struc(-1, name, False)');
  lines.push('    ');
  lines.push('    sptr = ida_struct.get_struc(sid)');
  lines.push('    if sptr is None:');
  lines.push('        return {"sid": sid, "members": []}');
  lines.push('    ');
  lines.push('    # Add function pointers at each slot');
  lines.push('    for slot_id, func_name in vfuncs:');
  lines.push('        offset = slot_id * 8  # x64: each pointer is 8 bytes');
  lines.push('        member = ida_struct.get_member(sptr, offset)');
  lines.push('        if member:');
  lines.push('            ida_struct.del_struc_member(sptr, offset)');
  lines.push('        ida_struct.add_struc_member(sptr, func_name, offset, ida_bytes.FF_QWORD, None, 8)');
  lines.push('    ');
  lines.push('    return {"sid": sid, "members": vfuncs}');
  lines.push('');

  // IDA 9 vtable creation
  lines.push('def create_vtable_ida9(name, vfuncs):');
  lines.push('    """IDA 9+: Create vtable using ida_typeinf"""');
  lines.push('    tif = ida_typeinf.tinfo_t()');
  lines.push('    til = ida_typeinf.get_idati()');
  lines.push('    ');
  lines.push('    # Check if vtable type already exists');
  lines.push('    if tif.get_named_type(til, name):');
  lines.push('        return {"tif": tif, "udt": None, "name": name, "members": vfuncs}');
  lines.push('    ');
  lines.push('    # Create vtable struct type data');
  lines.push('    udt = ida_typeinf.udt_type_data_t()');
  lines.push('    ');
  lines.push('    # Create function pointer type (void*)');
  lines.push('    func_ptr_type = ida_typeinf.tinfo_t()');
  lines.push('    void_type = ida_typeinf.tinfo_t()');
  lines.push('    void_type.create_simple_type(ida_typeinf.BTF_VOID)');
  lines.push('    func_ptr_type.create_ptr(void_type)');
  lines.push('    ');
  lines.push('    # Fill gaps and add function pointers');
  lines.push('    max_slot = max((slot for slot, _ in vfuncs), default=0)');
  lines.push('    slot_map = {slot: func_name for slot, func_name in vfuncs}');
  lines.push('    ');
  lines.push('    for slot in range(max_slot + 1):');
  lines.push('        udm = ida_typeinf.udm_t()');
  lines.push('        if slot in slot_map:');
  lines.push('            udm.name = slot_map[slot]');
  lines.push('        else:');
  lines.push('            udm.name = f"vfunc_{slot}"');
  lines.push('        udm.offset = slot * 8 * 8  # Convert to bits (slot * 8 bytes * 8 bits)');
  lines.push('        udm.type = func_ptr_type');
  lines.push('        udm.size = 64  # 8 bytes in bits');
  lines.push('        udt.push_back(udm)');
  lines.push('    ');
  lines.push('    # Create and register the vtable type');
  lines.push('    vtable_tif = ida_typeinf.tinfo_t()');
  lines.push('    if vtable_tif.create_udt(udt, ida_typeinf.BTF_STRUCT):');
  lines.push('        vtable_tif.set_named_type(None, name)');
  lines.push('    ');
  lines.push('    return {"tif": vtable_tif, "udt": udt, "name": name, "members": vfuncs}');
  lines.push('');

  // Apply vtable to struct helper
  lines.push('def apply_vtable_to_struct(struct_name, struct_handle, vtable_name, vtable_handle):');
  lines.push('    """Apply vtable type as first member of struct (IDA 8/9 compatible)"""');
  lines.push('    if IDA9:');
  lines.push('        return apply_vtable_to_struct_ida9(struct_name, struct_handle, vtable_name, vtable_handle)');
  lines.push('    else:');
  lines.push('        return apply_vtable_to_struct_ida8(struct_name, struct_handle, vtable_name, vtable_handle)');
  lines.push('');

  // IDA 8 apply vtable
  lines.push('def apply_vtable_to_struct_ida8(struct_name, struct_handle, vtable_name, vtable_handle):');
  lines.push('    """IDA 8.x: Add vtable pointer as first member"""');
  lines.push('    sid = struct_handle["sid"]');
  lines.push('    sptr = ida_struct.get_struc(sid)');
  lines.push('    if sptr is None:');
  lines.push('        return False');
  lines.push('    ');
  lines.push('    # Check if there is already a member at offset 0');
  lines.push('    member = ida_struct.get_member(sptr, 0)');
  lines.push('    if member:');
  lines.push('        # Don\'t overwrite existing vtable pointer');
  lines.push('        return True');
  lines.push('    ');
  lines.push('    # Add vtable pointer at offset 0');
  lines.push('    ida_struct.add_struc_member(sptr, "VTable", 0, ida_bytes.FF_QWORD, None, 8)');
  lines.push('    return True');
  lines.push('');

  // IDA 9 apply vtable
  lines.push('def apply_vtable_to_struct_ida9(struct_name, struct_handle, vtable_name, vtable_handle):');
  lines.push('    """IDA 9+: Add vtable pointer type as first member"""');
  lines.push('    members = struct_handle["members"]');
  lines.push('    ');
  lines.push('    # Check if there is already a member at offset 0');
  lines.push('    has_member_at_zero = any(m.get("offset", -1) == 0 for m in members)');
  lines.push('    if has_member_at_zero:');
  lines.push('        return True');
  lines.push('    ');
  lines.push('    # Insert vtable pointer at the beginning');
  lines.push('    vtable_member = {');
  lines.push('        "name": "VTable",');
  lines.push('        "offset": 0,');
  lines.push('        "size": 8,');
  lines.push('        "total_size": 8,');
  lines.push('        "is_array": False,');
  lines.push('        "array_count": 1,');
  lines.push('        "is_vtable_ptr": True,');
  lines.push('        "vtable_name": vtable_name,');
  lines.push('    }');
  lines.push('    members.insert(0, vtable_member)');
  lines.push('    return True');
  lines.push('');
  lines.push('');
}

function generateFieldLine(
  field: YamlField,
  structName: string,
  warnings: string[]
): string | null {
  const offset = parseOffset(field.offset);
  const fieldName = sanitizeIdentifier(field.name || `field_${toHex(offset)}`);

  // Check for array types
  const arrayInfo = parseArrayType(field.type);
  if (arrayInfo) {
    const baseSize = getTypeSize(arrayInfo.baseType);
    return `add_struct_member(struct_handle, "${fieldName}", ${toHex(offset)}, "${mapToIdaType(arrayInfo.baseType)}", ${baseSize}, True, ${arrayInfo.count})`;
  }

  // Regular type
  const idaType = mapToIdaType(field.type);
  const size = field.size || getTypeSize(field.type);

  return `add_struct_member(struct_handle, "${fieldName}", ${toHex(offset)}, "${idaType}", ${size})`;
}

function getEnumUnderlyingSize(underlying?: string): number {
  if (!underlying) return 4;

  const sizeMap: Record<string, number> = {
    'byte': 1,
    'sbyte': 1,
    'short': 2,
    'ushort': 2,
    'int': 4,
    'uint': 4,
    'long': 8,
    'ulong': 8,
  };

  return sizeMap[underlying.toLowerCase()] || 4;
}

export default idaExporter;
