/**
 * Ghidra script exporter
 * Generates Python/Java scripts for Ghidra that create data types
 */

import type { YamlStruct, YamlField, YamlEnum } from '../types.js';
import { parseOffset, toHex } from '../types.js';
import {
  type Exporter,
  type ExportOptions,
  type ExportResult,
  getTypeSize,
  sanitizeIdentifier,
  parseArrayType,
} from './base.js';

export const ghidraExporter: Exporter = {
  format: 'ghidra',
  extension: '.py',
  export: exportToGhidra,
};

function exportToGhidra(
  structs: YamlStruct[],
  enums: YamlEnum[],
  options: ExportOptions = {}
): ExportResult {
  const warnings: string[] = [];
  const lines: string[] = [];
  const categoryPath = options.namespace || '/FFXIVClientStructs';

  // Header
  lines.push('"""');
  lines.push('FFXIVClientStructs - Ghidra Type Import Script');
  lines.push('Generated by ffxiv-struct-tools');
  lines.push('');
  lines.push('Usage: In Ghidra, go to Window > Script Manager');
  lines.push('       Right-click and select "New Script"');
  lines.push('       Choose Python, paste this script, and run');
  lines.push('"""');
  lines.push('');
  lines.push('# @category FFXIVClientStructs');
  lines.push('# @keybinding');
  lines.push('# @menupath');
  lines.push('# @toolbar');
  lines.push('');
  lines.push('from ghidra.program.model.data import *');
  lines.push('from ghidra.program.model.data import StructureDataType, EnumDataType');
  lines.push('from ghidra.program.model.data import CategoryPath, DataTypeConflictHandler');
  lines.push('');

  // Helper class
  lines.push('class FFXIVTypeCreator:');
  lines.push('    """Helper class for creating FFXIV data types in Ghidra"""');
  lines.push('    ');
  lines.push('    def __init__(self, dtm):');
  lines.push('        self.dtm = dtm  # DataTypeManager');
  lines.push(`        self.category = CategoryPath("${categoryPath}")`);
  lines.push('        self.structs = {}  # Cache of created structs');
  lines.push('        self.enums = {}    # Cache of created enums');
  lines.push('    ');
  lines.push('    def get_primitive_type(self, name, size):');
  lines.push('        """Get a primitive data type by size"""');
  lines.push('        if name == "bool":');
  lines.push('            return BooleanDataType.dataType');
  lines.push('        elif name == "float":');
  lines.push('            return FloatDataType.dataType');
  lines.push('        elif name == "double":');
  lines.push('            return DoubleDataType.dataType');
  lines.push('        elif name == "char":');
  lines.push('            return CharDataType.dataType');
  lines.push('        elif size == 1:');
  lines.push('            return ByteDataType.dataType');
  lines.push('        elif size == 2:');
  lines.push('            return ShortDataType.dataType');
  lines.push('        elif size == 4:');
  lines.push('            return IntegerDataType.dataType');
  lines.push('        elif size == 8:');
  lines.push('            return LongLongDataType.dataType');
  lines.push('        else:');
  lines.push('            return ByteDataType.dataType');
  lines.push('    ');
  lines.push('    def create_enum(self, name, values, size=4):');
  lines.push('        """Create an enum data type"""');
  lines.push('        if name in self.enums:');
  lines.push('            return self.enums[name]');
  lines.push('        ');
  lines.push('        enum_dt = EnumDataType(self.category, name, size)');
  lines.push('        for val_name, val in values.items():');
  lines.push('            enum_dt.add(val_name, val)');
  lines.push('        ');
  lines.push('        self.dtm.addDataType(enum_dt, DataTypeConflictHandler.REPLACE_HANDLER)');
  lines.push('        self.enums[name] = enum_dt');
  lines.push('        return enum_dt');
  lines.push('    ');
  lines.push('    def create_struct(self, name, size, fields):');
  lines.push('        """Create a struct data type"""');
  lines.push('        if name in self.structs:');
  lines.push('            return self.structs[name]');
  lines.push('        ');
  lines.push('        struct_dt = StructureDataType(self.category, name, size)');
  lines.push('        ');
  lines.push('        for field in fields:');
  lines.push('            field_name = field.get("name", "field_%X" % field["offset"])');
  lines.push('            field_type = field.get("type", "byte")');
  lines.push('            field_offset = field["offset"]');
  lines.push('            field_size = field.get("size", 1)');
  lines.push('            is_array = field.get("is_array", False)');
  lines.push('            array_count = field.get("array_count", 1)');
  lines.push('            ');
  lines.push('            # Get or create the data type');
  lines.push('            if field_type in self.structs:');
  lines.push('                dt = self.structs[field_type]');
  lines.push('            elif field_type in self.enums:');
  lines.push('                dt = self.enums[field_type]');
  lines.push('            else:');
  lines.push('                dt = self.get_primitive_type(field_type, field_size)');
  lines.push('            ');
  lines.push('            # Handle arrays');
  lines.push('            if is_array:');
  lines.push('                dt = ArrayDataType(dt, array_count, dt.getLength())');
  lines.push('            ');
  lines.push('            try:');
  lines.push('                struct_dt.replaceAtOffset(field_offset, dt, dt.getLength(), field_name, None)');
  lines.push('            except:');
  lines.push('                # Field may overlap with existing, try insert');
  lines.push('                pass');
  lines.push('        ');
  lines.push('        self.dtm.addDataType(struct_dt, DataTypeConflictHandler.REPLACE_HANDLER)');
  lines.push('        self.structs[name] = struct_dt');
  lines.push('        return struct_dt');
  lines.push('');
  lines.push('');

  // Generate enum creation calls
  lines.push('def create_enums(creator):');
  lines.push('    """Create all enum types"""');

  if (enums.length === 0) {
    lines.push('    pass  # No enums');
  } else {
    for (const enumDef of enums) {
      const enumName = sanitizeIdentifier(enumDef.type);
      const size = getEnumSize(enumDef.underlying);

      lines.push(`    # ${enumDef.type}`);
      lines.push(`    creator.create_enum("${enumName}", {`);

      if (enumDef.values) {
        for (const [name, value] of Object.entries(enumDef.values)) {
          const safeValue = typeof value === 'string' ? parseInt(value, 10) : value;
          lines.push(`        "${sanitizeIdentifier(name)}": ${safeValue},`);
        }
      }

      lines.push(`    }, ${size})`);
      lines.push('');
    }
  }

  lines.push('');

  // Generate struct creation calls
  lines.push('def create_structs(creator):');
  lines.push('    """Create all struct types"""');

  if (structs.length === 0) {
    lines.push('    pass  # No structs');
  } else {
    for (const struct of structs) {
      const structName = sanitizeIdentifier(struct.type);
      const size = struct.size || 0;

      lines.push(`    # ${struct.type} (size: ${toHex(size)})`);
      if (options.includeComments && struct.notes) {
        for (const noteLine of struct.notes.split('\n')) {
          lines.push(`    # ${noteLine}`);
        }
      }
      lines.push(`    creator.create_struct("${structName}", ${size}, [`);

      if (struct.fields && struct.fields.length > 0) {
        for (const field of struct.fields) {
          // Add field note as comment if enabled
          if (options.includeComments && field.notes) {
            lines.push(`        # ${field.name || 'field'}: ${field.notes}`);
          }
          const fieldDict = generateFieldDict(field, warnings);
          lines.push(`        ${fieldDict},`);
        }
      }

      lines.push('    ])');
      lines.push('');
    }
  }

  lines.push('');

  // Main function
  lines.push('def main():');
  lines.push('    """Main entry point"""');
  lines.push('    dtm = currentProgram.getDataTypeManager()');
  lines.push('    creator = FFXIVTypeCreator(dtm)');
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Starting type import...")');
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating enums...")');
  lines.push('    create_enums(creator)');
  lines.push(`    print("[FFXIVClientStructs] Created ${enums.length} enums")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Creating structs...")');
  lines.push('    create_structs(creator)');
  lines.push(`    print("[FFXIVClientStructs] Created ${structs.length} structs")`);
  lines.push('    ');
  lines.push('    print("[FFXIVClientStructs] Import complete!")');
  lines.push('');
  lines.push('# Run the script');
  lines.push('main()');
  lines.push('');

  return {
    content: lines.join('\n'),
    filename: options.output || 'ffxiv_structs_ghidra.py',
    structCount: structs.length,
    enumCount: enums.length,
    warnings,
  };
}

function generateFieldDict(field: YamlField, warnings: string[]): string {
  const offset = parseOffset(field.offset);
  const fieldName = field.name || `field_${toHex(offset)}`;

  // Check for array types
  const arrayInfo = parseArrayType(field.type);
  if (arrayInfo) {
    const baseSize = getTypeSize(arrayInfo.baseType);
    return `{"name": "${sanitizeIdentifier(fieldName)}", "offset": ${offset}, "type": "${mapToGhidraType(arrayInfo.baseType)}", "size": ${baseSize}, "is_array": True, "array_count": ${arrayInfo.count}}`;
  }

  // Handle pointers
  if (field.type.endsWith('*') || field.type.startsWith('Pointer<')) {
    return `{"name": "${sanitizeIdentifier(fieldName)}", "offset": ${offset}, "type": "pointer", "size": 8}`;
  }

  // Regular types
  const ghidraType = mapToGhidraType(field.type);
  const size = field.size || getTypeSize(field.type);

  return `{"name": "${sanitizeIdentifier(fieldName)}", "offset": ${offset}, "type": "${ghidraType}", "size": ${size}}`;
}

function mapToGhidraType(yamlType: string): string {
  const typeMap: Record<string, string> = {
    'bool': 'bool',
    'byte': 'byte',
    'sbyte': 'byte',
    'char': 'char',
    'short': 'short',
    'ushort': 'short',
    'int': 'int',
    'uint': 'int',
    'long': 'longlong',
    'ulong': 'longlong',
    'float': 'float',
    'double': 'double',
    '__int8': 'byte',
    '__int16': 'short',
    '__int32': 'int',
    '__int64': 'longlong',
    'void': 'void',
  };

  return typeMap[yamlType] || yamlType;
}

function getEnumSize(underlying?: string): number {
  if (!underlying) return 4;

  const sizeMap: Record<string, number> = {
    'byte': 1,
    'sbyte': 1,
    'short': 2,
    'ushort': 2,
    'int': 4,
    'uint': 4,
    'long': 8,
    'ulong': 8,
  };

  return sizeMap[underlying.toLowerCase()] || 4;
}

export default ghidraExporter;
